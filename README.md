# CSV_Test
TEST: CSV Converter 

CSV converter

В текстовом файле "1629936492_0_v1_1545203239277.csv" есть множесто строчек, состоящих из 3х чисел, разделенные запятой.
Пример

    321.8666666666667,1509951000000,0
    312.6666666666667,1509951060000,0
    322.25,1509951120000,0
    334.23333333333335,1509951180000,0
    342.01666666666665,1509951240000,0
    359.0,1509951300000,0
    349.9,1509951360000,0
    343.8333333333333,1509951420000,0
    342.8333333333333,1509951480000,0
    343.06666666666666,1509951540000,0

Первое число - это уровень освещенности на улице в люксах.
Второе число - это колличество милисекунд после начал эпохи (дата и время).
Третье число - не важно.
каждая запись сделана раз в минуту.

Чтобы можно было нормально прочитать значение каждого столбика, используйте
QStringList qsl = input.split(',');

и затем переводите строчки в нужный формат, используя toDouble и toLongLong

QStringList qsl = input.split(',');
if(qsl.size()==3){
    double lux = qsl.at(0).toDouble();
    qint64 unixTimeMilSec = static_cast<qint64>(qsl.at(1).toLongLong());
    QDateTime dt = QDateTime::fromMSecsSinceEpoch(unixTimeMilSec);
    qsTemp = dt.toString();
    qDebug() << "Lux :" << lux << "unixTimeSec" << unixTimeSec << "dt: " << qsTemp << "Current hour: " << dt.time().hour();
}

Чтобы можно было работать с числом и временем из milSec, нужно использовать
и
QDateTime dt;
qint64 val;

если нужно отдельно получить время или дату:

QDate cur_date;  
QTime cur_time;  
  
cur_date = dt.date();  
cur_time = dt.time(); 

Читайте документацию по QDateTime

Ваша задача - сделать программу, которая анализирует лог освещоности.
Жалательно с графическим интерфейсом, но на 3 сойдет и текстовый.

Задание для третей группы:
Найти самый "пасмурный" день, когда среднее заначение всех часов за день меньше всего.
